# SRP : 단일 책임 원칙

역사적으로 SRP 는 아래와 같이 기술되어 왔다. 

> 단일 모듈은 변경의 이유가 하나, 오직 하나 뿐이어야 한다.

소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다. 위 원칙은 아래와 같이 바꿔 말할 수 있다.

> 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.

여기에서 사용자나 이해관계자라는 단어를 쓰는것은 올바르지 않다. 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자가 두 명 이상일 수도 있기 때문이다. 여기에서는 이런 의미보다는 집단, 즉 해당 변경을 요청하는 한 명 이상의 사람들을 가리킨다. 이러한 집단을 액터(actor) 라 부른다.

따라서 SRP 의 최종의미는 아래와 같이 된다.

> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다. (모듈 = 소스파일)

응집된(cohesive) 라는 단어가 SRP 를 암시한다.

## 징후 1 : 우발적 중복

- 급여 애플리케이션의 Employee 클래스

```java
public class Employee {
  /**
   * 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용
   */
  public void calculatePay() {} // CFO actor
  /**
   * 인사팀에서 기능을 정의하며, COO 보고를 위해 사용
   */
  public void repostHours() {} // COO actor
  /**
   * 데이터베이스 관리자(DBA)가 기능을 정의하며, CTO 보고를 위해 사용
   */
  public void save() {} // CTO actor
}
```

Employee 클래스는 세 가지 메서드를 가진다. 세가지 메서드는 각각 다른 액터를 책임진다. 따라서 위 클래스는 SRP 를 위반하는 클래스이다.

개발자가 이 세 메서드를 Employee 라는 단일 클래스에 배치하여 세 액터가 결합되어 버렸다. 이 결합으로 인해 CFO 팀에서 결정한 조치가 COO 팀이 의존하는 무언가에 영향을 줄 수 있다.

예를 들어 calculatePay() 메서드와 reportHours() 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유하고, 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours() 라는 메서드에 넣었다.

이제 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 하자. 반면 인사를 담당하는 COO 팀에서는 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른 목적으로 사용하기 때문에, 이 같은 변경을 원치 않는다고 해보자.

CFO 팀의 변경요청사항을 적용하기 위해서 regularHours() 에 가서 알고리즘을 수정한다. 하지만 개발자는 해당 메서드가 COO 팀에서도 사용 중이라는 것을 눈치 못챈다. 따라서 나중에 COO 팀 직원이 reportHours() 메서드가 생성한 보고서를 여전히 이용하지만, 잘못된 수치로 인해 많은 금액을 잘못된 지출을 하게 되었으며 많은 문제가 생길 수 있다.

따라서, `서로 다른 액터가 의존하는 코드를 서로 분리` 해야 한다.

## 징후 2 : 병합

예를 들어 DBA 가 속한 CTO 팀에서 Employee 테이블 스키마를 약간 수정하기로 하고, 이와 동시에 인사 담당자가 속한 COO 팀에서는 reportHours() 메서드의 보고서 포맷을 변경하기로 했다면, 각 팀에 있는 두 명의 개발자가 서로 변경사항을 적용하고 마스터와 병합(Merge)를 할 것이다. 하지만 이들의 변경사항은 서로 충돌하며 문제가 발생한다. 

따라서, 이 문제를 벗어나는 방법은 `서로 다른 액터를 뒷받침하는 코드를 서로 분리` 하는 것이다.

## 해결책

위 문제들에 대한 해결책은 다양하다. 메서드를 각각 다른 클래스로 이동시키는 방식이 있다. 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다. 즉, 아무런 메서드가 없는 간단한 데이터 구조인 `EmployeeData` 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.


