# 함수형 프로그래밍

함수형 프로그래밍 패러다임에서 핵심이 되는 기반은 `람다(Lambda)` 계산법이다. 

## 자바와 클로저의 차이

자바 프로그램은 가변 변수(mutable variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다. 예를 들면 for 문의 i 같은 것이다.
하지만 클로저는 이러한 가변 변수가 없다. 즉, x 와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.

> 함수형 언어에서 변수는 변경되지 않는다.

## 불변성과 아키텍처

아키텍트는 왜 변수의 가변성을 염려하는가? 그 이유는 `경합(race), 교착 상태(deadlock), 동시 업데이트(concurrent update)` 문제가 모두 가변 변수로 인해
발생되기 때문이다. 다시 말해 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는
가변 변수가 없다면 절대로 생기지 않는다.

아키텍트라면 동시성(concurrency) 문제에 지대한 관심을 가져야만 한다.

## 가변성의 분리

불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 `가변 컴포넌트와 불변 컴포넌트로 분리`하는 일이다.
불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되면, 어떤 가변 변수도 사용되지 않는다.

현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

## 비교 및 스왑(compare and swap) 알고리즘

클로저에 있는 `swap!` 함수는 전통적인 비교 및 스왑(compare and swap) 알고리즘을 전략으로 사용한다. 

```closure
(def counter (atom 0)) ; count 를 0 으로 초기화 한다.
(swap! counter inc) ; counter 를 안전하게 증가시킨다.
```

여기서 atom 변수는 특수한 형태의 변수로 값을 변경하려면 반드시 swap! 함수를 사용해야 한다.

먼저 counter 값을 읽은 후 inc 함수로 전달한다. inc 함수가 반환되면 counter 의 값은 잠기게 되고 inc 함수로 전달했던 값과 비교한다. 
만약 값이 같다면 inc 함수가 반환한 값이 counter 에 저장디ㅗ고 잠근은 해제된다. 값이 같이 않다면 잠금을 해제한 후 처음부터 재시도한다.

atom 기능은 간단한 애플리케이션에는 적합하지만, 여러 변수가 상호 의존하는 상황에서는 더 정교한 장치를 사용하여 동시성 문제를 해결해야 한다.

## 트랜잭션 메모리(transactional memory)

트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다. 이런 접근법의 예가 클로저의 atom 이다.
따라서 트랜잭션 메모리 같은 기법을 사용하면 동시성과 경합 문제로부터 가변 변수를 보호할 수 있다.

## 이벤트 소싱(event sourcing)

이벤트 소싱(event sourcing)은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
이 기법을 사용하려면 저장 공간을 충분히 확보해야 하며, 더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다.

결과적으로 애플리케이션은 CRUD 가 아니라 CR 만 수행한다. 저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고,
따라서 완전한 함수형으로 만들 수 있다.

> 소스 코드 버전 관리 시스템이 이벤트 소싱 방법으로 동작한다.
