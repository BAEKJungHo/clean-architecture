# 좋은 코드 작성을 위한 팁

## 예외

예외(Exception)는 예외 상황에 사용되도록 의도된 도구인 만큼 예외를 잘 사용하는 것은 좋은 코드를 작성하는데 중요하다.

### 에러 코드

C 언어와 같이 예외가 지원되지 않는 언어에서는 응답 값으로 에러코드를 설정하여 상태를 구분지어야 했는데, 가끔 예외를 지원하는 개발 언어를 사용하면서도
여전히 에러 코드를 반환하는 개발자가 있다. `에러 코드는 가독성을 심하게 저해한다.` 에러코드가 비지니스 로직과 예외 처리 로직을 한 곳에 혼재시켜버리기 때문이다.

문제는 이 뿐만이 아니다. 호출자 코드에서 실수로 에러 코드를 검사하지 않고 넘어갔다면 에러가 발견되지 않게 된다. null 을 반환할 수도 있는 함수를 호출해놓고
그 결괏값에 대한 null 검사를 하지 않는 것과 같다. 때에 따라서는 null 검사를 하지 않은 것보다 더 위험할 수도 있다.

반면 `에러 상황에 예외(Exception)를 던지면 전방위에 걸쳐 흩어져 있던 에러 코드 검사로직이 전부 사라져 코드의 가독성이 향상` 된다. 
실수로 에러 처리를 하지 못해도 에러가 밖으로 전파되기 때문에 실수를 바로 잡기 쉽다.

```java
Elevator elevator = ElevatorManager.getOptimalElevator(movingRequest);

if(elevator.getStatus() == Elevator.VALID_STATUS){
    ElevatorAction elevatorAction = 
        elevator.moveTo(movingRequest.getDepartureFloor());
    
    if(elevatorAction.getStatus() == ElevatorAction.ARRIVED){
            ElevatorAction elevatorAction = 
                elevator.moveTo(moveRequest.getDestinationFloor());

            if(elevatorAction.getStatus() == ElevatorAction.ARRIVED){
                ...
            }else{
                logger.error("Elevator does not move.");
                status = elevatorAction.getStatus();
            }
    }else{
            logger.error("Elevator does not move.");
            status = elevatorAction.getStatus();
    }
}else{
    ...
}
```

호출되는 함수가 예외를 던지도록 리팩토링 한다면 아래 처럼 바꿀 수 있다.

```java
Elevator elevator = ElevatorManager.getOptimalElevator(movingRequest);
elevator.moveTo(movingRequest.getDepartureFloor());
elevator.moveTo(movingRequest.getDestinationFloor());
```

## 예외(Exception) 관련 팁

1. 예외를 잡았다면 예외 상황을 복구하거나 적절히 처리해야만 합니다. 예외는 감추어져서는 안됩니다. 예외를 잡아 놓고 아무것도 하지 않거나 간단히 로그만 찍고 넘어간다면 정말 심각한 문제 상황을 놓치게 될 수도 있습니다. 만약 예외를 처리하기 어렵다고 판단되면 더 적절한 곳에서 예외를 처리할 수 있도록 예외를 밖으로 전파하는 것이 낫습니다.

2. 최대한 표준 예외를 사용하는 것이 좋긴 하지만 예외 전환을 고려해보는 것도 좋습니다. 이때는 새로 던질 예외가 비즈니스 로직에 더 적합한 의미가 있거나 특정 사용 기술에 대한 종속을 피하기 위함이거나 클래스나 함수의 추상화 수준에는 처리되어야 할 예외가 적합하지 않은 경우여야만 합니다. 예외를 전환할 때는 원인이 되는 예외를 담아 함께 던져주어야 원인 파악에 도움이 될 것입니다.

3. 예외는 예외 상황에만 사용해야 합니다. 비즈니스 로직의 일환으로 예외를 사용하는 anti pattern을 보게 되면 동료 개발자들은 많은 혼란을 느낄 것입니다. 특히 비즈니스 로직의 일환으로 예외를 사용하는 코드에서는 예외가 잘 발생할 것입니다. 예외가 일종의 정상적인 흐름의 일부니까요. 예외는 생성에 큰 비용이 드는 객체입니다. 자주 발생하는 만큼 성능적으로도 좋지 않습니다.

4. 예외는 예외 상황 파악에 필요한 실패 관련 메세지를 담아야 합니다.

5. 예외 발생 이전과 예외 발생 이후에 어플리케이션의 상태에 어떤 변화가 있어서는 안 됩니다. 예를 들어 계좌이체를 위해 출금을 이미 완료하였고 상대방 계좌로 입금 도중 예외가 발생하였다고 합시다. 이런 경우 반드시 출금계좌의 상태가 원래 상태로 복원되어야만 합니다.

6. 예외 클래스는 보통 Exception으로 끝나도록 이름 짓습니다. 암묵적인 룰이라고 봐도 되겠습니다.

## 변수의 수직 유효 범위

변수의 수직 유효 범위란 변수가 처음 생성되고 닫는 중괄호를 만나 소멸할 때까지의 코드상의 수직 범위(거리)를 의미한다.

변수의 수직 유효 범위는 좁을수록 좋다. 변수의 유효 범위가 넓을수록 실수로 인한 버그 발생 가능성이 매우 증가하고 코드를 보는 사람이 혼란을 겪을 여지가 크기 때문이다.

## try 블록의 범위

볌수의 유효 범위와 마찬가지로 try 절도 좁을수로 좋다. 귀찮은 마음에 전체 함수 범위를 감싸면 중괄호로 인한 가독성 저하 발생뿐만 아니라 올바른 예외 처리 기회를 놓칠 수도 있기 때문이다.

개발 중에는 예상 못했던 예외는 우연히 다른 예외 처리 로직에 의해 그 존재가 감춰지는 것보다 실수를 눈치챌 수있게 밖으로 던져지는 것이 더 길게보면 안전하다.

## if 절 안의 코드는 딱 한줄 만

좋은 함수 작성 방법 섹션에서 메서드당 들여쓰기 깊이를 한 단계만 가지라고 하였습니다. 
유사하게, 저는 될 수 있으면 if절 안의 코드는 딱 한 줄만 넣으려고 시도합니다. 
중괄호 안에 복잡한 코드를 욱여넣지 말고 그 코드를 밖으로 빼내어 다른 함수로 정의하고 이를 호출하는 게 중괄호 중첩을 피하기에 좋은 방법입니다.

유사하게 try 절로 감싸진 코드가 있다면 이 코드를 밖으로 빼내어 함수로 만들고 중괄호 중첩이 발생하기 좋은 try 절 내부에서 이 함수를 호출하도록 코드를 작성하시는 게 좋습니다.

## 클래스가 많아질 경우

클래스가 너무 많은 책임을 가지고 있는 경우 분리할 수 있는지 파악하고, 더 적합한 작은 클래스로 분리하는 과정이 일반적으로 올바른 방법인데
클래스가 너무 많아지는 경우 시스템 흐름 파악이 어려워지는 경향이 있다. 따라서 이러한 이유로 클래스가 많아지는 것을 싫어하는 사람도 있다.

이에 대해서는 팀내 룰을 따르는 것이 좋다. 그러나 클래스의 역할이 잘 정해지고 이름을 충분히 잘 짓는 다면 어느정도 완화 가능한 문제이기도 하다.

## 의미 없는 변수 사용

아른 이유 없이 임시 변수에 어던 값을 담는 코드가 있다.

```java
String temp = func();
return temp;
```

그냥 return temp(); 하는게 좋다. 코드에 이런 임시변수가 늘어날 수록 가독성에 큰 어려움이 생긴다. 도메인 로직이 복잡할 수록, 함수의 길이가 길수록, 
특히 변수의 수직 유효범위가 클수록 이런 의미없는 변수는 혼란만 일으킨다.

## 쿼리와 명령 분리. CQRS(Command and Query Responsibility Segregation) 

함수는 상태의 변화를 일으키지 않고 결괏값을 반환하는 `쿼리`와 시스템의 상태를 변경시키는 `명령`들 중 하나여야만 한다.

자바 언어의 Map(swift, python 등의 Dictionary를 생각하시면 됩니다.) 클래스에는 put() 이라는 메서드가 있습니다. 
이 메서드는 Map 자료구조에 key 와 value 를 저장합니다. 이 메서드에는 특이한 점이 있습니다. 바로 void 일 것으로 예상되지만 그렇지 않은 반환 타입입니다. 이 메서드는 put을 할 때 key 에 해당하는 기존 value 를 반환합니다.

> putAndGetIfValueAleadyExist() 라고 이름 짓는 게 더 정확하겠습니다만 자바 개발자 입장에서 put 메서드가 저렇게 길어지면 많이 어색하게 느껴질 것 같습니다.

함수는 쿼리 또는 명령으로 분리하라고 했습니다. 쿼리는 상태 변경 없이 결괏값을 반환하기 때문에 사용자는 이 함수를 걱정 없이 호출해도 되겠습니다. 다른 부작용이 없기 때문에요. HTTP GET 메서드를 생각하시면 되겠습니다.

> HTTP GET 메서드는 여러 번을 호출해도 서버 상태 변경 등과 같은 부작용이 없게 설계되어야 합니다.

## Tell, Don't ask

예를 들어 엘리베이터를 관리하는 `ElevatorManager` 와 `Elevator` 클래스가 있다고 가정하자

```java
void moveElevator(int floorNumber) {
  if(elevator.currentFloor = floorNumber)
    return;
    
  elevator.move(floorNumber);
  elevator.currentFloor = floorNumber;
}
```

ElevatorManager 클래스는 Elevator 의 세세한 부분을 잘 알고 있다. 이런 코드와 같이 다른 객체의 내부 상태에 접근하는(직접 가져와서 특정값과 비교)방식은 변경에 취약하다.

나중에 비지니스 로직이 복잡해져서 건물의 층을 의미하는 Floor 타입이 추가되었다고 가정하겠다.

Elevator 클래스의 Integer 타입 필드인 currentFloor의 타입이 변경된다.

위와 같은 구조에서는 Elevaotr의 currentFloor 필드뿐만 아니라 elevator.currentFloor 를 참조하던 ElevatorManager의 moveElevator() 함수도 변경되어야 한다.

코드는 아래와 같이 변경되어야 좋다.

```java
class Elevator{
    private integer currentFloor;
    
    void move(int floorNumber){
        if(currentFloor == floorNumber)
            return;
    moveInternal()
    this.currentFloor = floorNumber
    }
}

class ElevatorManager{
    private Elevator elevator;

    void moveElevator(int floorNumber){
        elevator.move(floorNumber);
    }
}
```

이처럼 객체에 내부 상태를 `ask(elevator.currentFloor == floorNumber)`하지 말고 `tell(move())` 하면 캡슐화를 깨지 않아 
변경에 닫힌 코드 작성을 가능하게 하며 ask 방식에서 자주 발생하는 코드 중복을 피할 수 있다.
 
## null 반환
 
null 을 반환하는 함수는 가급적 만들지 않는게 좋다. 호출자 코드의 실수로 인해 예외가 발생할 수 있기 때문이다.
 
null 을 반환하는 함수의 경우 함후를 호출하는 코드는 꼭 null 검사를 해야한다.
 
값이 없음을 표현하는 값을 반환하긴 해야겠는데 null 은 반환하지말라니, 어떻게 해야 좋을까?

우선 `널 오브젝트(Null Object)` 반환을 고려해봐야 한다. 

> 널 오브젝트(Null Object) 란 값이 없는 상태를 대신하여 아무 일도 하지 않는 객체를 의미한다.

아래 코드와 같이 NoPet 클래스는 울부짖지 않는다.

```java
class NoPet extends Pet {
  @Override
  public void howl() {
    return;
  }
}
```

널 오브젝트를 반환하면 호출자 코드에서 실수로 null 검사를 하지 않아 `null 관련 예외나 예기치 못한 버그가 발생하는 경우`를 방지할 수 있다. 
호출자 코드에서 null 검사를 없애 가독성 향상에도 좋다.

> 널 오브젝트 패턴은 함수 호출자 코드가 지저분해진다면 쓰느니만 못하다.

## 배열이나 컬렉션에 값이 없을 때는 ?

값이 없을 때는 `빈 배열이나 빈 컬렉션을 반환` 하는 것을 고려해봐야 한다.

```java
return new ArrayList<>();
```

빈 리스트를 매번 새로 생성하여 반환하는 것보다는

```java
return Collections.emptyList();
```

같이 이미 존재하는 객체를 사용하는게 좋다. 널 오브젝트도 마찬가지이다. 
굳이 매번 만들 필요 없고 여러 곳에서 사용해도 문제가 없으면 싱글톤 오브젝트로 만들어두고 재사용하는게 좋다.

## Optional

코틀린과 같은 최신 언어는 언어 차원에서 null safety 관련 지원을 합니다. 그러나 자바같이 비교적 오래된 언어의 경우에는 어떻게 할까요? 그냥 null 을 반환해버려야 할까요?

대안은 Optional 입니다.

자바 언어에서 Optional 은 왜 쓰는 것일까요?? 

바로 호출자 코드에 null이 반환될 수 있음을 알리고 이를 처리하는 코드를 강제하여 `실수로 null 검사를 하지 않는 경우를 방지하기 위해서` 입니다.

Optional 로부터 실제 사용할 결괏값을 가져오려면 null 일 경우 default 객체를 반환하도록 할지 다른 예외를 던질지 아니면 그냥 NullPointerException 이 발생하도록 둘지를 호출자가 정해야만 합니다. 상황에 따라 if 조건문으로 null 검사를 하는 것보다 코드 가독성을 향상시킬 수도 있습니다.

Optional 을 반환하는 메서드는 절대 null 을 반환해서는 안 됩니다. 자바를 사용하는 누구도 Optional 을 반환하는 함수가 null 을 반환할 거라고 생각하지 않기 때문입니다. 지키지 않는다면 호출자 코드에는 NullPointerException 이 발생할 것입니다.

## else 를 없애라

```java
if(~) {

} else {

}
```

위와 같은 코드를 보면 else 를 없앨 방법이 없는지부터 고민해야한다. 가급적 if 절에서 조건을 검사한 후 바로 리턴하거나 예외를 던지도록 코드를 수정해
else 절을 없애주는게 중괄호 중첩을 막는 좋은 방법이다.

즉, 이런 코드를

```java
for(Apple apple : apples){
  if(apple.isSellableQuality()){
    //blar blar
    //blar blar
    //blar blar
    fruitBox.add();
  }else{
    throw new BadQualityAppleFoundedException();
  }
}
```

아래와 같이 바꿀 수 있는지 고민해본다는 뜻이다.

```java
for(Apple apple : apples){
  if(apple.isNotSellableQuality())
    throw new BadQualityAppleFoundedException();
  //blar blar
  //blar blar
  //blar blar
  fruitBox.add();
}
```

예제가 간단해 가독성에 큰 차이가 느껴지지 않을 수 있지만, 코드 길이가 조금만 더 늘어도 차이가 확연히 느껴질 것이다. 
특히 길이가 긴 함수에서  else 절은 로직 파악을 어렵게 해 코드 탐구를 처음부터 다시 시작하게 하는 주요인이 됩니다.
긴 if 절의 로직을 따라가다 else 를 보게 되면 머릿속이 하얘지는 경험을 하시게 될 것입니다.

만약, else 를 없애기 어려운 상황이라면 if 절에는 정상적인 상황에 대한 조건을 두고 비정상적인 상황을 else 절에 두는 게 직관상 좋다.

> apple.isSellableQuality() 에서 apple.isNotSellableQuality() 로 함수를 수정한 것도 유사한 이유에서이다.

## 지식의 저주

if(category == “S001”) 와 같은 코드를 본 적 있으신가요?


아마 문자열 타입 상수형 변수 이름(예를 들어 ProductCategory.SNEAKERS)을 사용해야 할 자리에 도메인에 너무 익숙한 나머지 문자열 리터럴을 써버린 케이스일 것이라고 판단됩니다.

이러한 이유로 저는 문자열 상수를 좋아하지 않습니다. 문자열 상수, 인트 타입 상수는 개발자를 하드 코딩하도록 유혹합니다.

코드 작성자에게 물어보면 “category 의 값이 S001 이면 스니커즈 상품인 경우입니다.” 라고 대답할 것입니다.

모두가 알 수 있는 공통 언어를 사용합시다. 코드는 처음 보는 사람도 이해할 수 있어야 합니다. 잘 이름 지은 상수를 사용하거나 isSneakers(variable) 과 같은 함수를 사용해서 조건문을 캡슐화하는 것이 좋겠습니다. 물론 제대로 된 해결책이 아닙니다. 더 좋은 방법은 문자열, 인티저 타입 상수 말고 다른 방법이 있는지 알아보시는 것입니다. 자바라면 enum 을 사용하시는 게 좋겠습니다.

## 카테고리성 데이터는 enum 사용

예를들어 윷놀이 처럼 도개걸윷모를 나타내기위해서 1~5로 비교하는코드에서 숫자 6을 써버리면 에러가 발생할 수도 있고 가독성도 좋지않다. 
이런 경우에는 enum 으로 DO, GAE, ... , MO 이런식으로 나타내는것이 좋다.

enum 으로 바뀌면 개발자의 실수를 컴파일러가 알아챌 수 있다.

## Don't reinvent the wheel

이미 개발된 기능을 다시 만드는 데 시간을 쓰지 말라는 뜻이다. 실제로 본인이 사용 중인 클래스에 이미 있는 기능을 직접 개발하거나 다른 라이브러리를
추가해가며 사용하지 말라는 것이다.

## 로우레벨 클래스

개발을 하다 보면 로우 레벨 클래스의 기능이 필요할 때가 있다. 다만, 로우 레벨 클래스를 사용할 때는 `Don't reinvent the wheel` 을 꼭 기억해야 한다.

## 기술의 의도

- 질문 

```
"컨트롤러(MVC 패턴의 C라고 생각하시면 됩니다.)의 메서드 호출 전/후에 어떤 작업을 하려고 하는 데 인터셉터가 좋을까요? AOP가 좋을까요?"
```

- 답변

```
"AOP는 컨트롤러 호출만 고려해서 만들어진 기술이 아니다. 그러나 인터셉터는 컨트롤러 호출 전/후의 동작을 고려해서 설계된 스프링 MVC(웹) 컴포넌트이다."
```

차이를 아시겠나요? 분명 둘 다 함수 호출 전/후에 원하는 작업을 하게 해준다는 점에서는 기능적으로 같습니다. 그러나 인터셉터는 컨트롤러 호출 전/후의 작업을 고려해 설계된 스프링의 웹 관련 컴포넌트인 만큼 그 설계 목적에 맞게 AOP보다 웹 관련 작업에 더 특화된 기능을 제공한다는 장점이 있습니다.

## 문맥

객체가 갖는 값(상태)과 이를 처리하는 로직(행위)은 한 곳에서 관리 되어야 좋습니다.

객체의 상태와 먼 거리에 있는 코드에서 행위가 이루어지면 중복 코드 발생, 비즈니스 로직 오해로 인한 중요 계산 로직 누락 등의 문제가 발생할 수 있으며 한 클래스의 코드를 수정할 때 다른 클래스마저 수정해야 함을 기억해야 하므로 유지보수와 협업에 좋지 않습니다.

## 일급 컬렉션

소트웍스 앤솔러지의 "객체지향 생활 체조" 에서는 컬렉션을 포함한 클래스에는 반드시 컬렉션 외의 다른 멤버 변수가 없어야 한다라고 한다.

컬렉션이 기본으로 제공하는 add, remove, iterate 와 같은 기본 동작 외에 validation, filtering 등 추가 로직이 필요한 경우 일급 컬렉션을 고려해볼 것을 추천한다.

```java
Set<Apple> applesToBeSold = new HashSet<>();

for(Apple apple : apples)
    if(apple.isSellableQuality())
        applesToBeSold.add(apple);
```  

필터링을 통해 판매할 사과를 고르는 작업을 아주 간략하게 표현하였습니다. 
위 코드와 같이 컬렉션(applesToBeSold)에 필터링 등 로직이 필요하다면 이런 로직을 컬렉션 자체에 직접 적용하기보다는

```java
class ApplesToBeSold {
    private Set<Apple> apples = new HashSet<>();
    
    public void add(Apple apple){
        if(apple.isSellableQuality())
            apples.add(apple);
    }
}
```
```java
ApplesToBeSold applesToBeSold = new ApplesToBeSold();
for(Apple apple : apples)
    applesToBeSold.add(apple);
```

위와 같이 Apple 의 Set 만 멤버 변수로 정의한 클래스를 만들고 filtering 작업을 이 클래스 내부에 담는 것이 좋다. 보시다시피 판매될 사과라는 상태와
이 상태에 적용되는 필터링 작업이 ApplesToBeSol 이라는 클래스 한 곳에 모두 담겨있음을 알수 있다.

> 일급 컬렉션 관련 정말 좋은 예제는 jojoldu(이동욱)님의 블로그를 보시는 것을 추천합니다.

## Primitive 타입 지양

어떤 값을 표현할 때 무의식적으로 원시 타입이나 문자열을 사용하려는 유혹이 들 때가 많습니다. 아래와 같이 휴대 전화 번호를 저장한 문자열 변수가 있다고 하겠습니다.

```java
String phoneNumber = "+8201089241810"
```

위 phoneNumber 변수로부터 국번 정보를 가져오려면 아래와 같은 문자열 파싱이 매번 필요합니다. 가독성도 없고 중복되기도 아주 쉽습니다.

```java
phoneNumber.substring(0, 3);
```

휴대 전화 번호 형식이야 모르는 사람이 없기 때문에 위의 문자열 파싱 코드가 무슨 행위를 의미하는지를 아는 것은 문제가 아닐 수 있습니다. 그러나 도메인 지식이 필요한 상황에서는 위와 같은 방식으로 코드를 작성하지 않는게 좋습니다.

다음과 같이 핸드폰 번호를 나타내는 클래스를 만드는 것은 어떨까요?

```java
Class PhoneNumber{
    private CountryCode countryCode;
    private WirelessCarrier wirelessCarrier;
  
    ...
      
    public PhoneNumber(String phoneNumber){
        validatePhoneNumber(phoneNumber);
        ...
    }
  
    private validatePhoneNumber(String phoneNumber){
        // validate phone number format
    }
  
    public CountryCode getCountryCode(){
        return countryCode;
    }
  
    ...
}
```

이제 매번 문자열을 파싱할 필요 없이 getter호출만으로 국번을 가져올 수 있습니다. 물론 그뿐만이 아닙니다.

PhoneNumber 클래스에는 핸드폰 번호라는 `상태`와 핸드폰 번호 형식의 검증이라는 `행위`가 한 곳에 담기게 되었습니다. 

## 배열(리스트)의 표현력

명시적인 표현이 필요한 곳에 배열이나 리스트를 사용하지 마세요. 예를 들기 위해 한 서비스에 다음과 같은 내부 룰이 있다고 하겠습니다.

"getAllCookies() 함수가 반환하는 배열의 첫 번째 원소는 사용자의 계정, 두 번째 원소는 사용자의 나이, 세 번째 원소는 사용자의 권한을 의미한다."

따로 작성해 둔 문서를 보지 않는 한, 아니면 getAllCookies() 함수에 쓰인 주석을 보지 않는 한, 도메인에 익숙지 않은 개발자는 이 함수의 반환 값에 혼란을 느낄 수밖에 없습니다. `[0]` 이라는 인덱스와 userEmail 사이에는 전혀 연결 고리가 없기 때문입니다.

"주석이나 문서를 보면 되잖아"라고 생각하시는 분도 계시겠습니다. 그러나 코드로 충분히 표현할 수 있는 것을 주석이나 문서에 위임하는 것은 좋은 개발 습관이 아닙니다. 주석과 문서는 최신 코드의 상태를 대변할 수 없습니다. 실수나 귀찮음에 갱신을 빼먹을 가능성이 아주 크기 때문입니다.

이 함수를 사용하는 코드는 보통 다음과 같습니다.

```java
//cookies[0]는 유저의 이메일을 cookies[1]은 유저의 나이를 cookies[2]는 
// 유저의 role을 의미한다.
String[] cookies = getAllCookies();
String userEmail = cookies[0];
String userAge = cookies[1];
String userRole = cookies[2];
```

만약 팀에 새로 합류한 개발자가 getAllCookies() 함수를 사용해야 하는 상황을 맞이했다고 가정해보겠습니다.



서비스의 도메인에 익숙지 않은 개발자는 아마 cookies 배열의 각 원소가 무엇을 의미하는지를 파악하기 위해 getAllCookies() 함수 내부를 샅샅이 뒤져야 할 것입니다.


이 함수가 반환하는 배열과 그 배열의 각 인덱스에 해당하는 값의 의미가 getAllCookies() 함수의 주석에 언급되었더라도 제대로 된 개발자라면 이를 신뢰하지 않을 것입니다. 다시 말하지만, 주석은 코드의 최신 상태에 맞춰 현행화되지 못할 가능성이 크기 때문입니다.

주석을 제대로 업데이트하지 않은 것이 잘못 아니냐는 의견도 있겠습니다. 그러나 정말 잘못은 부작용 많은 방식(주석 의존)을 주의하면 된다는 식으로 얼버무려 사용하는 것이라고 생각합니다. 가급적 주석 사용을 피하고 표현력 있고 명시적인 코드를 작성하려고 노력하세요.

만약 getAllCookies() 함수가 다음과 같이 그 의미를 바로 알 수 있도록 추상화된 타입을 반환하도록 바뀐다면

```java
User user = getUserInfoFromCookie();
user.getUserEmail();
user.getUserAge();
...
```

동료 개발자가 혼란을 겪을 일은 없을 것입니다. [0]이 getUserEmail()로, [1]이 getUserAge()로 변하며 향상된 표현력에 주목해보시기 바랍니다. 만약 객체 사용을 지양하는 팀에서 일하고 계시거나 하시게 된다면 차라리 맵을 반환해서라도 조금이나마 `표현력`을 높이시기 바랍니다.

## 하나의 개념, 하나의 상태

하나의 개념엔 하나의 상태만 들어가야 혼란이 없습니다. 서로 다른 성격의 원소를 타입이 같다는 이유로 동일한 컬렉션에 우겨 넣거나, 두 가지 이상의 상태를 한 변수에 담는 경우 동료를 혼란스럽게 합니다.

다음은 후자의 경우에 대한 예입니다.

```java
String startDate = startAndEndDate.split(";")[0];
String endDate = startAndEndDate.split(";")[1];
```

## 정적 팩토리 메서드

정적 팩토리 메서드란 객체 생성을 담당하는 public static 메서드를 말한다. 생성자와 비교하면 public static 으로 선언된 패곹리 메서드는 몇 가지 장점이 있다. 그중 이 글의 주제오 관련해 가장 중요한 장점은 바로 메서드 이름을 활용해 생성되는 객체의 특성을 표현할 수 있다는 점이다.

> 디자인 패턴의 패곹리 메서드 패턴을 의미하는 것이 아니다.

Color라는 클래스가 있다고 합시다. 색상은 보통 RGB, CMYK, HSV 등의 모델로 표현됩니다. 아래는 생성자를 호출해 각 색상 모델을 기반으로 한 Color 타입 객체를 생성하는 코드의 예시입니다.

```java
Color rgbColor = new Color(255, 155, 100);
Color cmykColor = new Color(0, 39, 61, 0);
Color hsvColor = new Color(21, 60.8, 100.0);
```

변수 이름에 색상 모델명을 담지 않았다면 각각의 Color 객체가 어떤 색상 모델을 바탕으로 생성되었는지 알기 어려웠을 것입니다. 변수명만으로 구분은 가능하지만, 객체 생성 방식의 명시성이 확실히 떨어집니다. 또한, 변수명에 색상 모델 정보가 들어가는 게 적절하지 않을 가능성이 크기도 합니다. 예를 들면 profileBackgroundColor 와 같이 변수명에는 도메인에 더 적합한 이름이 좋을 것입니다.

위의 객체 생성 코드를 정적 팩토리 메서드를 이용해 표현해보겠습니다.

```java
Color rgbColor = Color.fromRGB(int red, int green, int blue);
Color cmykColor = Color.fromCMYK(int cyan, int magenta, int yellow, int black);
Color hsvColor = Color.fromHSV(double hue, double saturation, double value);
```

확실히 생성자를 통한 객체 생성보다 `명시성이 향상`된 것을 알 수 있습니다. 메서드 이름만으로 어떤 Color 객체가 생성될지 쉽게 파악됩니다.

생성자 수가 한 개 혹은 두 개 정도밖에 되지 않을 때는 굳이 정적 팩토리 메서드를 사용할 필요가 있을지 고민해보시는 것이 좋겠습니다. 위 예제로 말씀드린 Color의 경우는 RGB, CMYK, HSV 말고도 더 다양한 색상 모델이 있습니다. 객체 생성 방식이 여러 가지가 있는 경우 또는 같은 시그니처의 생성자를 정의할 필요가 있을 때 정적 팩토리 메서드를 정의하는 것을 추천합니다.

> 유사하게 빌더패턴 을 남용하는 경우도 있습니다. 보통 좋아 보이는 새 기법을 처음 접한 분들이 남용을 많이 하는 것 같습니다. 빌더패턴은 생성자나 정적팩토리 메서드의 매개변수가 너무 많을 경우, 대부분 인자가 선택적 인자(필수적으로 설정되지 않아도 되는 인자)인 경우에 사용하는 것이 가장 바람직합니다.

## 다형성은 만병통치약?

객체지향이라는 개념을 처음 접할 때는 다형성이 항상 정답인 것만 같아 보이고는 합니다. if-else, switch 구문은 초보적이라는 생각이 들기도 합니다.

과연다형성이 항상 정답일까요? 그렇지는 않습니다.

인터페이스를 구현한 클래스가 3개 있다고 해보겠습니다. 만약 인터페이스의 메서드가 하나 추가된다면 이를 구현한 세 개의 클래스 모두에 변경이 발생하게 됩니다. 

당연한 말이죠.

만약 절차 지향적이라고들 하는 if 또는 switch로 분기하던 방식이었다면 조건문 하나만 추가하면 끝났을 것입니다.

그렇다면 언제 다형성이 좋고 언제 절차 지향적 방식이 좋을까요?

이것은 변경이 어디서 이루어지느냐에 따라 결정됩니다. 변경이 어디서 이루어지는지를 파악하면 인터페이스를 구현한 클래스가 추가될 가능성이 큰지 아니면 인터페이스에 새로운 함수가 추가될 가능성이 더 큰지를 따져볼 수 있습니다.

## YAGNI(You aren't gonna need it)

클래스나 함수는 실제로 필요할 때 만드는게 좋다.

객체지향, 디자인 패턴같은 개념을 처음 접하고 나면, 무리하게 확장성을 고려하며 쓰지도 않을 클래스나 함수를 미리 만드는 경향이 생기는 것 같다. 그러나 개발 중엔 새로운 요구 사항이나 설계 변경이 자주 발생하기 때문에 미리 만들어봐야 헛수고가 되는 경우가 많다. 모든 예측에는 틀릴 가능성이 내포되어 있기 때문이다. 특히 현업의 프로젝트같이 복잡한 시스템일수록 변경의 요소가 많아 정확한 예측이 어렵다.

> "심플 소프트웨어" 에서는 소프트웨어의 미래 변화상에 관한 예측 말고 현재 데이터, 현재 소프트웨어 시스템을 기반으로 결정을 내릴 때 올바른 방향으로 향할 가능성이 훨씬 크다고 한다.

만약 미리 만들어둔 클래스나 함수가 새로 바뀐 환경이나 설계에 맞게 적절히 수정되지 않았을 경우 버그의 원인이 될지도 모른다.

> 실제로 사용하지 않는 코드일수록 수정되지 않을 가능성이 커진다.

### 유연한 대응

구체적인 변화를 예측하지 말고 현재의 필요에 의해서만 개발하란 말이 변화에 대응할 필요 자체가 없다는 말은 아닙니다.

미래에 설계가 바뀔 수 있음을 고려해 개발하되, 프로그램에 어떤 변화가 발생할 것이고 어떤 구체적인 기능이 필요하게 될 것인지 까지 설계에 당장 담지 말라는 의미입니다.

그렇다면 미래에 설계가 바뀔 수 있음을 고려한 개발이란 무엇일까요? 바로 여러 `클린코드 작성법과 SRP, DIP 등의 객체지향 개발 원칙`을 바탕으로 프로그램을 설계, 개발하는 것입니다. 프로그램이 이런 설계/개발 원칙을 기반으로 작성되어야 나중에 변경이 필요할 때 유연하게 대응할 수 있습니다.

## Rule of Three

여러 리팩토링 기법과 디자인 패턴같은 설계 기법이 코드 중복을 피하고자 탄생하였습니다. 아시겠지만 중복된 코드가 많을수록 코드 변경 횟수가 많아져 유지보수에 좋지 않기 때문입니다.

그러나 중복 코드를 너무 민감하게 대비하실 필요는 없습니다. 어떤 코드가 중복될 것이 예상된다거나, 한두 개 정도의 코드 중복이 보인다고 서둘러 코드를 리팩토링하는 것은 자칫하면 잘못된 설계의 원인이 될 수 있습니다. 위에 말씀드렸듯 개발 중엔 새로운 요구 사항이나 설계 변경이 자주 발생하기 때문입니다.

보통 중복 코드가 세 개 이상 발견되는 경우에 리팩토링을 하면 잘못된 설계를 피할 수 있다고 합니다. 이 때쯤 되면 중복을 없애기 위해 공통으로 뽑아낼 요소가 명확해지기 때문입니다.

하나의 기준일 뿐 필수 원칙은 아닙니다. 특히 기존 프로그램을 점진적으로 리팩터링하는 경우에는 위 원칙을 크게 신경 쓰지 않아도 되겠습니다. 신규 프로젝트 개발과 비교하면 비즈니스 요구사항이 어느 정도 정해져 있기 때문입니다.

> “Duplication is far cheaper than the wrong abstraction” – Sandi Metz, All the little things

## 중복 허용

코드가 애매하게 반복되어 공통 요소를 뽑기 어려운 경우에는 중복을 어느 정도 허용하는 게 나을 수 있습니다. 애매한 중복 코드를 없애려다 도리어 코드 구조가 복잡해지는 경우가 발생하기 때문입니다. 개인적으로 중복 해결보다 `코드의 단순성과 명료성`이 중요하다고 생각합니다.

