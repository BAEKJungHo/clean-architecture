# 시스템

시스템 수준에서도 깨끗함을 유지하는 방법(높은 추상화 수준을 유지하는 방법)에 대해서 배워보자.

## 시스템 제작과 시스템 사용을 분리하라

`제작(construction)` 과 `사용(use)`은 아주 다르다.

> 소프트웨어 시스템은 준비 과정(애플리케이션 객체를 제작하고 의존성을 서로 연결하는 과정)과 런타임 로직을 분리해야 한다

### 관심사(concern)

시작 단계는 모든 애플리케이션이 풀어야할 `관심사(concern)`이다. `관심사의 분리`는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.

대다수의 애플리케이션은 관심사를 분리하지 않고 준비 과정 코드를 런타임 로직과 뒤섞어 개발한다.

- Bad Case

```java
public Service getService() {
  if(service == null) {
    service = new MyServiceImpl(...); // Lazy Initialization or Lazy Evaluation
  }
  return service;
}
```

지연 로딩(혹은 계산 지연)이라는 기법이다. 장점은 실제 사용하기 전까지 객체를 생성하지 않는다. 따라서 부하가 적어지고 애플리케이션 시작 시간이 빨라진다. 그리고 null 을 반환하지 않는다.
하지만, getService() 가 MyServiceImpl 의 생성자 인수에 명시적으로 의존한다.
또한 일반 런타임 로직에다, 객체 생성 로직을 섞어놔서 작게나마 단일 책임 원칙(SRP)를 깬다.

## 확장

처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고
확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다.

## 자바 프록시

자바 프록시는 단순한 상황에 적합하다. 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예다. 하지만 JDK 에서 제공하는 동적 프록시는 인터페이스만 지원한다.
클래스 프록시를 사용하려면 CGLIB, ASM, Javassist 같은 바이트 코드 처리 라이브러리가 필요하다.

## 순수 자바 AOP 프레임워크

순수 자바 관점을 구현하는 스프링 AOP, JBoss, AOP 등과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다.

__스프링은 비지니스 논리를 POJO 로 구현한다. POJO 는 순수하게 도메인에 초점을 맞춘다.__ 따라서 POJO 는 엔터프라이즈 프레임워크에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간다하며, 사용자 스토리를 올바르게 구현하기 쉽고, 미래 스토리에 맞춰 코드를 유지보수하기도 쉽다.


